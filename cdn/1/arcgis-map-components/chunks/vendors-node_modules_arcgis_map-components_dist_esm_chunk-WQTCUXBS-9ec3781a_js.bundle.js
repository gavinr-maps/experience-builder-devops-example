/*! For license information please see vendors-node_modules_arcgis_map-components_dist_esm_chunk-WQTCUXBS-9ec3781a_js.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([["vendors-node_modules_arcgis_map-components_dist_esm_chunk-WQTCUXBS-9ec3781a_js"],{2676:(e,t,o)=>{o.d(t,{A:()=>F,a:()=>Q,b:()=>Y,c:()=>X,l:()=>z,p:()=>q,u:()=>B});var n=o(4336),s=o(8960);var r,i=(r=63,e=>{const t=e.manager.internals.members;return Object.entries(t??{}).filter((([e,[t]])=>0!=(t&r))).map((([e])=>e))}),a=(e,t)=>e.manager.internals.members?.[t]?.[0];function c(e,t){const o=a(e,t);return void 0===o?void 0:32&o?"state":"prop"}var l=class{constructor(){this.resolve=()=>{},this.reject=()=>{},this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}};function h(e,t,o){const{subscribe:n}=function(e){const t=e.join(","),o=d[t];if(void 0!==o)return o;const n=new Set,s=new MutationObserver((e=>n.forEach((t=>t(e)))));s.observe(document.documentElement,{attributes:!0,attributeFilter:e,subtree:!0});const r={subscribe:e=>(n.add(e),{remove:()=>{n.delete(e),0===n.size&&(s.disconnect(),d[t]=void 0)}})};return d[t]=r,r}(t);return n((t=>{const n=t.some((t=>function(e,t){let o=e;for(;o;){if(o===t)return!0;if(!o.parentNode)return!1;o=o.parentNode instanceof ShadowRoot?o.parentNode.host:o.parentNode}return!1}(e,t.target)));n&&o()}))}var d={};function p(e,t,o){const n=function(e,t){let o=e;for(;o;){const e=o.closest(t);if(e)return e;const n=o.getRootNode();if(n===document)return null;o=n.host}return null}(e,`[${t}]`);return n?.getAttribute(t)??o}function m(e){try{return e?.()}catch(t){console.error(t,e)}}async function u(e){try{return await e()}catch(t){console.error(t,e)}}var y=new Set(["ar","bg","bs","ca","cs","da","de","el","en","es","et","fi","fr","he","hr","hu","id","it","ja","ko","lt","lv","nl","nb","pl","pt-BR","pt-PT","ro","ru","sk","sl","sr","sv","th","tr","uk","vi","zh-CN","zh-HK","zh-TW"]),f="en";async function g(e,t,o=""){const n=`${t}/${o}`,s=`${n}${e}.json`;return _[s]??(_[s]=b(e,n)),await _[s]}var _={};async function b(e,t){const o=`${t}${e}.json`;try{const e=await fetch(o);if(e.ok)return await e.json()}catch(e){return console.error(e),v}return e===f?v:await b(f,t)}var v=new Proxy({},{get:(e,t)=>{return o=t.toString(),(n=o.replaceAll(/([a-z])([A-Z])/gu,"$1 $2")).charAt(0).toUpperCase()+n.slice(1);var o,n}});function w(e){const t=p(e,"lang",navigator.language||f);if(y.has(t))return{lang:t,t9nLocale:t};const o=t.slice(0,2);return{lang:t,t9nLocale:y.has(o)?o:f}}function C(e,t,o,n){let s;const r=()=>{(async function(e,t,o=e.tagName.toLowerCase().replace("arcgis-","")){const{lang:n,t9nLocale:s}=w(e),r=`${t}/${o}/t9n`,i=`${o}.t9n.`,a=await g(s,r,i);return{lang:n,t9nLocale:s,t9nStrings:a}})(e,t,n).then((e=>{s?.lang===e.lang&&s.t9nLocale===e.t9nLocale&&s.t9nStrings===e.t9nStrings||o(e),s=e})).catch(console.error)};return r(),h(e,["lang"],r)}var k=Symbol("controller");var L,P=["The value you passed is not a controller and not a controller exports. If ","your controller exports a literal value, try making your controller export ","an object instead"].join(""),x=class e{constructor(t){this._ready=new l,this._lifecycleDisconnected=[],this.connectedCalled=!1,this.willLoadCalled=!1,this.didLoadCalled=!1,this[L]=!0,this.ready=this._ready.promise,this._exports=U(this),this._exportWatchers=new Set;const o=function(e){if("addController"in e)return e;throw new Error("Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line")}(t??e.internals.retrieveComponent(new.target.name));Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:o}),this.component.addController(this);const n=this.component.manager;this.connected=n?.connected,this.internals=n?.internals,e.internals.setParentController(this),"hostDestroy"in this&&this.component.manager.ensureHasDestroy(),void 0!==n&&queueMicrotask((()=>this.catchUpLifecycle()));const s=this;this._callbacks={hostConnected:"hostConnected"in this?[()=>s.hostConnected?.()]:[],hostDisconnected:"hostDisconnected"in this?[()=>s.hostDisconnected?.()]:[],hostLoad:"hostLoad"in this?[()=>s.hostLoad?.()]:[],hostLoaded:"hostLoaded"in this?[()=>s.hostLoaded?.()]:[],hostRender:"hostRender"in this?[()=>s.hostRender?.()]:[],hostRendered:"hostRendered"in this?[()=>s.hostRendered?.()]:[],hostUpdate:"hostUpdate"in this?[()=>s.hostUpdate?.()]:[],hostUpdated:"hostUpdated"in this?[()=>s.hostUpdated?.()]:[],hostDestroy:"hostDestroy"in this?[()=>s.hostDestroy?.()]:[],hostLifecycle:"hostLifecycle"in this?[()=>s.hostLifecycle?.()]:[]}}catchUpLifecycle(){if(this.connectedCalled)return;this.triggerConnected();!this.component.manager.willLoadCalled||this.triggerLoad().then((()=>{!this.component.manager.didLoadCalled||this.triggerLoaded()})).catch(console.error)}get exports(){return this._exports}set exports(e){this._exports!==e&&(this._exports=e,this.connectedCalled&&this.component.requestUpdate(),this._exportWatchers.forEach((t=>t(e)))),this._ready.resolve(e)}setProvisionalExports(e){this._exports=U(e),this._exportWatchers.forEach((e=>e(this._exports)))}watchExports(e){const t=t=>m((()=>e(t)));return this._exportWatchers.add(t),()=>{this._exportWatchers.delete(t)}}get use(){return e.internals.setAmbientComponent(this.component),e.internals.use}get useRef(){return e.internals.setAmbientComponent(this.component),e.internals.useRef}bypassSetter(t){e.internals.shouldBypassSetter=!0;try{return t()}finally{e.internals.shouldBypassSetter=!1}}bypassReadonly(t){e.internals.shouldBypassReadonly=!0;try{return t()}finally{e.internals.shouldBypassReadonly=!1}}bypassGetter(t){e.internals.shouldBypassGetter=!0;try{return t()}finally{e.internals.shouldBypassGetter=!1}}dynamicGetSet(e,t){this.genericGetSet(e,t)}genericGetSet(e,t){var o,n;const s=t;void 0!==s.get&&((o=this.internals.getters)[e]??(o[e]=[]),this.internals.getters[e].unshift(s.get)),void 0!==s.set&&((n=this.internals.setters)[e]??(n[e]=[]),this.internals.setters[e].unshift(s.set))}watch(e,t){var o;if(void 0===a(this.component,e))throw new Error(`Trying to watch a non-@Prop, non-@State property "${e}". Either convert it into a @State() or use manager.getSet/dynamicGetSet`);(o=this.internals.allWatchers)[e]??(o[e]=[]);const n=this.internals.allWatchers[e],s=t,r=(e,t,o)=>m((()=>s(e,t,o)));return n.push(r),()=>{const e=n.indexOf(r);-1!==e&&n.splice(e,1)}}onConnected(e){this._callbacks.hostConnected.push(e)}onDisconnected(e){this._callbacks.hostDisconnected.push(e)}onLoad(e){this._callbacks.hostLoad.push(e)}onLoaded(e){this._callbacks.hostLoaded.push(e)}onRender(e){this._callbacks.hostRender.push(e)}onRendered(e){this._callbacks.hostRendered.push(e)}onUpdate(e){this._callbacks.hostUpdate.push(e)}onUpdated(e){this._callbacks.hostUpdated.push(e)}onDestroy(e){this.component.manager.ensureHasDestroy(),this._callbacks.hostDestroy.push(e)}onLifecycle(e){this._callbacks.hostLifecycle.push(e),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(e)}triggerConnected(){this._callbacks.hostConnected.forEach(m),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){this._callbacks.hostDisconnected.forEach(m),this._lifecycleDisconnected.forEach(m),this._lifecycleDisconnected=[]}async triggerLoad(){this.willLoadCalled||(this.willLoadCalled=!0,this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(u)),this._ready.resolve(this._exports))}triggerLoaded(){this.didLoadCalled||(this._callbacks.hostLoaded.forEach(m),this.didLoadCalled=!0)}async triggerRender(){this._callbacks.hostRender.length>0&&await Promise.allSettled(this._callbacks.hostRender.map(u))}triggerRendered(){this._callbacks.hostRendered.forEach(m)}async triggerUpdate(){this._callbacks.hostUpdate.length>0&&await Promise.allSettled(this._callbacks.hostUpdate.map(u))}triggerUpdated(){this._callbacks.hostUpdated.forEach(m)}triggerDestroy(){this._callbacks.hostDestroy.forEach(m)}triggerLifecycle(){this._callbacks.hostLifecycle.forEach((e=>this._callLifecycle(e)))}_callLifecycle(e){const t=m(e);(Array.isArray(t)?t:[t]).forEach((e=>{"function"==typeof e?this._lifecycleDisconnected.push(e):"object"==typeof e&&"function"==typeof e.remove&&this._lifecycleDisconnected.push(e.remove)}))}};L=k,x.internals=new class{constructor(){this._ambientControllers=[],this.use=async(e,t)=>{const o=this._useRefSync(e);if(void 0===o){if("function"==typeof t){const e=new Error(`Unable to resolve a controller from the provided value, so can't watch it's exports. ${P}`);console.error(e)}return e}if(await o.ready,"function"==typeof t){if(void 0===o.watchExports)throw new Error("The controller must implement watchExports method to support watching exports");const e=o.watchExports((o=>t(o,e)))}return o.exports},this.useRef=async e=>{const t=this._useRefSync(e);if(void 0===t)throw new Error(`Unable to resolve a controller from the provided value. ${P}`);return await t.ready,t},this.shouldBypassSetter=!1,this.shouldBypassGetter=!1,this.shouldBypassReadonly=!1,this.elementToInstance=new WeakMap}setAmbientComponent(e){this._ambientComponent!==e&&(this._ambientComponent=e,queueMicrotask((()=>{this._ambientComponent===e&&(this._ambientComponent=void 0)})))}retrieveComponent(e){if(void 0===this._ambientComponent)throw new Error([`Unable to find out which component ${e||"this"} controller `,"belongs to. This might happen if you tried to create a controller ","outside the component. If so, please wrap your controller ","definition in an arrow function, ","`const myController = ()=>makeController(...);` and call that","function inside the component `my = myController();`, or ","define your controller using makeGenericController/GenericController ","instead.\n","If you wish to use a controller inside an async controller, ","make sure you are using controller.use.\n","You might also have multiple instances of Controllers loaded"].join("\n"));return this._ambientComponent}setParentController(e){if(void 0===e)return void(this._ambientControllers=[]);const t=this._ambientControllers.indexOf(e);this._ambientControllers=-1===t?[...this._ambientControllers,e]:this._ambientControllers.slice(0,t+1),queueMicrotask((()=>{this._ambientControllers=[]}))}retrieveParentControllers(){return this._ambientControllers}setAmbientChildController(e){this._ambientChildController!==e&&(this._ambientChildController=e,queueMicrotask((()=>{this._ambientChildController===e&&(this._ambientChildController=void 0)})))}retrieveAmbientChildController(){const e=this._ambientChildController;return this._ambientChildController=void 0,e}_useRefSync(e){const t=this.retrieveAmbientChildController();if(void 0!==t)return t;const o=S.internals.retrieveComponent().manager.internals.resolveExports(e);return void 0!==o?o:(e=>"object"==typeof e&&null!==e&&(k in e||"hostConnected"in e||"hostDisconnected"in e||"hostUpdate"in e||"hostUpdated"in e))(e)?e:void 0}};var S=x,D=class extends S{constructor(e){super(e)}watch(e,t){return super.watch(e,t)}dynamicGetSet(e,t){super.genericGetSet(e,t)}};function U(e){if("object"!=typeof e&&"function"!=typeof e||null===e)return e;const t=new Proxy(e,{get(e,o,n){if(!E.has(o)||!(o in e)||e[o]!==t)return o in e||o in Promise.prototype||"symbol"==typeof o?"function"==typeof e?e[o]:Reflect.get(e,o,n):void console.error(`Trying to access "${o.toString()}" on the controller before it's loaded. ${R}`)},set:(e,t,o,n)=>(console.error(`Trying to set "${t.toString()}" on the controller before it's loaded. ${R}`),Reflect.set(e,t,o,n))});return t}var E=new Set(["exports","_exports"]),R=["This might be the case if you are trying to access an async controller in ","connectedCallback(). Or, if you are using it inside of ","componentWillLoad()/another controller without controller.use. Example correct ","usage:\n","makeController(async (component, controller)=>{ await controller.use(someOtherController); });"].join("");function W(e,t,o){const n=Object.keys(e),s=n.length;void 0===j&&queueMicrotask(O),j??(j=new Map);let r=j.get(e);return void 0===r&&(r={callbacks:[],keyCount:s},j.set(e,r)),r.keyCount!==s&&(r.callbacks.forEach((e=>e(n))),r.callbacks=[],r.keyCount=s),r.callbacks.push((n=>{const r=e=>m((()=>t(e))),i=n[s];void 0===i?r(void 0):e[i]===o?r(i):r(void 0)})),o}var j=void 0;function O(){Array.from(j?.entries()??[]).forEach((([e,{callbacks:t}])=>{const o=Object.keys(e);t.forEach((e=>e(o)))})),j=void 0}var A=class{constructor(e){this.enabledWatchers={},this.allWatchers={},this.trackKey=(e,t,o)=>{const n=Array.isArray(e)?e:[e];let s=n.length+1;const r=e=>{s-=1,void 0!==e&&(s=0),0===s&&t(e)};return n.forEach((e=>this.component.manager.trackPropertyKey(e,(t=>r(void 0===t?void 0:{key:t,host:e,type:"property",domValue:void 0})),o))),this.component.manager.trackPropKey(((e,t)=>{const o=void 0===e?void 0:c(this.component,e);r(void 0===e?void 0:{key:e,host:this.component,type:o??"prop",domValue:"prop"===o?t:void 0})}),o),o},this.trackPropKey=(e,t,o=!1)=>(this._trackedValue!==G&&this._trackedValue!==t&&this._firePropertyTrackers(void 0,void 0,void 0),0===this._keyTrackers.length&&queueMicrotask((()=>this._firePropertyTrackers(void 0,void 0,void 0))),this._trackedValue=t,this._keyTrackers.push(((n,s,r)=>m((()=>e(t===s||o?n:void 0,r))))),t),this._trackedValue=G,this._keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this._exports=new WeakMap,Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:e})}_firePropertyTrackers(e,t,o){const n=this._keyTrackers;this._trackedValue=G,this._keyTrackers=[],n.forEach((n=>n(e,t,o)))}getSetProxy(e,t,o){const n=Object.getPrototypeOf(this.component);this._getSetProxy(n,e,t,o,"class");const s=Object.getPrototypeOf(this.component.el);n!==s&&this._getSetProxy(s,e,t,o,"html")}_getSetProxy(e,t,o,n,s){const r=this.component,i=a(r,t),c=Object.getOwnPropertyDescriptor(e,t),l="html"===s;if(void 0===c?.set||void 0===c.get){if(void 0!==c&&"value"in c)throw new Error(`getSet() should only be used on Stencil's @Prop and @State properties. For internal component properties, use regular get/set syntax. Tried to use it on "${t}" in ${r.el.tagName}`);if(l)return;throw new Error(`Unable to find "${t}" property on the ${r.el.tagName} component`)}const{get:h,set:d}=c,p=!($ in h)&&o,m=!($ in d)&&n;if(!p&&!m)return;const u=p?function(){let e=h.call(this);const o=S.internals.elementToInstance.get(this);if(S.internals.shouldBypassGetter||void 0===o)return e;const n=o.manager.internals;e=n.accessorGetter[t](e,t);const s=n.getters[t]??T;for(let o=0;o<s.length;o++)e=s[o](e,t);return e}:h,y=m?function(e){const o=h.call(this);let n=function(e,t=8){return null==e||"object"==typeof e||"function"==typeof e?e:0!=(4&t)?"false"!==e&&(""===e||!!e):0!=(2&t)?Number.parseFloat(e.toString()):0!=(1&t)?String(e):e}(e,i);const s=S.internals.elementToInstance.get(this);if(void 0===s)return void d.call(this,e);const r=s.manager.internals;if(n===o)d.call(this,e);else{const e=S.internals.shouldBypassSetter?T:r.setters[t]??T;for(let s=0;s<e.length;s++)n=e[s](n,o,t);n=r.accessorSetter[t](n,o,t),d.call(this,n),n!==o&&r.enabledWatchers[t]?.forEach((e=>e(n,o,t)))}r._keyTrackers.length>0&&r?._firePropertyTrackers(t,e,o)}:d;p&&Object.defineProperty(u,$,{value:!0}),m&&Object.defineProperty(y,$,{value:!0}),Object.defineProperty(e,t,{...c,get:u,set:y})}markExports(e,t){("object"==typeof t&&null!==t||"function"==typeof t)&&this._exports.set(t,e)}resolveExports(e){return"object"==typeof e&&null!==e||"function"==typeof e?this._exports.get(e):void 0}},T=[],$=Symbol("controllersCustomAccessor"),G=Symbol("nothing"),I=Promise.all([(0,s.l)(),(0,s.m)()]);var M=e=>e,B=e=>new N(e),N=class extends D{constructor(e){const t=new Set;var o,s;o=e,s={addController:e=>{t.add(e)},removeController:e=>{t.delete(e)},requestUpdate:()=>(0,n.f)(e)},Object.entries(s).forEach((([e,t])=>{if(e in o)throw new Error(`Unable to extend object because property "${e}" is already defined`);o[e]=t})),super(e),this._connected=new l,this.internals=new A(this.component),this.connected=this._connected.promise,this.hasDestroy=!1,this.destroyed=!1,this._updatePromise=new l,this._originalLifecycles={},this.trackPropertyKey=W,this.trackPropKey=this.internals.trackPropKey,this.trackKey=this.internals.trackKey,this._readonlySetter=(e,t,o)=>{if(S.internals.shouldBypassReadonly)return e;throw"prop"===c(this.component,o)&&(0,n.f)(this.component),new Error(`Cannot assign to read-only property "${o}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(e)}"`)},this.devOnlySetPersistentControllerData=void 0,this.devOnlyGetPersistentControllerData=void 0,this.component.manager=this,function(e){const t=e.constructor,o=t.__registerControllers?.(e)??void 0;if(t.__registerControllers=void 0,"object"!=typeof o)throw new Error("Failed to retrieve internal component meta. Make sure you have the useComponentsControllers() Rollup Plugin for Stencil Controllers configured in your Stencil config.");e.manager.internals.members=o}(e),this._controllers=t,this.exports=void 0,this.hasDestroy="preserveOnDisconnect"in this.component&&"function"==typeof this.component.destroy,this.hasDestroy&&this.watch("preserveOnDisconnect",(()=>this._preserveOnDisconnectWatcher())),this._bindLifecycleMethods(),Object.defineProperty(e,"updateComplete",{get:async()=>await this._updatePromise.promise}),this.internals.reactiveUtilsIntegration=function(e){const t=i(e),o=e.manager.internals;return t.forEach((e=>{o.accessorGetter[e]=M,o.accessorSetter[e]=M,o.getSetProxy(e,!0,!0)})),async(n=t)=>{const[s,{subclass:r,property:i}]=await I;class a extends s{}const c=(e,t)=>h[t];function l(e,t,o){return void 0!==h&&(h[o]=e),e}e.manager.bypassGetter((()=>n.forEach((t=>{o.accessorGetter[t]=c,o.accessorSetter[t]=l,i({value:e[t]})(a.prototype,t)}))));const h=new(r(e.el.tagName)(a))}}(this.component),S.internals.setParentController(void 0),S.internals.setAmbientComponent(e),S.internals.elementToInstance.set(e.el,e),S.internals.elementToInstance.set(e,e)}_bindLifecycleMethods(){const e=this.component;this._originalLifecycles={connectedCallback:e.connectedCallback,disconnectedCallback:e.disconnectedCallback,componentWillLoad:e.componentWillLoad,componentDidLoad:e.componentDidLoad,componentWillRender:e.componentWillRender,componentDidRender:e.componentDidRender,componentWillUpdate:e.componentWillUpdate,componentDidUpdate:e.componentDidUpdate,destroy:e.destroy},e.connectedCallback=this._connectedCallback.bind(this),e.disconnectedCallback=this._disconnectedCallback.bind(this),e.componentWillLoad=this._componentWillLoad.bind(this),e.componentDidLoad=this._componentDidLoad.bind(this),e.componentWillRender=this._componentWillRender.bind(this),e.componentDidRender=this._componentDidRender.bind(this),e.componentWillUpdate=this._componentWillUpdate.bind(this),e.componentDidUpdate=this._componentDidUpdate.bind(this),this.hasDestroy&&(e.destroy=this.destroy.bind(this))}ensureHasDestroy(){if(!this.hasDestroy)throw new Error(K)}_connectedCallback(){if(this.destroyed){const e=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${e} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the preserveOnDisconnect prop.`)}this.internals.enabledWatchers=this.internals.allWatchers,O(),this._connected.resolve(),this._controllers.forEach((e=>"triggerConnected"in e?e.triggerConnected():m((()=>e.hostConnected?.())))),this._originalLifecycles.connectedCallback?.call(this.component)}_disconnectedCallback(){this.destroyed||(this._controllers.forEach((e=>"triggerDisconnected"in e?e.triggerDisconnected():m((()=>e.hostDisconnected?.())))),this._originalLifecycles.disconnectedCallback?.call(this.component),this.hasDestroy&&this._preserveOnDisconnectWatcher())}async _componentWillLoad(){await this.internals.reactiveUtilsIntegration(),await Promise.allSettled(Array.from(this._controllers,(async e=>"triggerLoad"in e?await e.triggerLoad():await u((async()=>await(e.hostLoad?.())))))),await(this._originalLifecycles.componentWillLoad?.call(this.component))}_componentDidLoad(){this._controllers.forEach((e=>"triggerLoaded"in e?e.triggerLoaded():m((()=>e.hostLoaded?.())))),this._originalLifecycles.componentDidLoad?.call(this.component)}async _componentWillRender(){await Promise.allSettled(Array.from(this._controllers,(async e=>"triggerRender"in e?await e.triggerRender():await u((async()=>await(e.hostRender?.())))))),await(this._originalLifecycles.componentWillRender?.call(this.component))}_componentDidRender(){this._controllers.forEach((e=>"triggerRendered"in e?e.triggerRendered():m((()=>e.hostRendered?.())))),this._originalLifecycles.componentDidRender?.call(this.component)}async _componentWillUpdate(){await Promise.allSettled(Array.from(this._controllers,(async e=>"triggerUpdate"in e?await e.triggerUpdate():await u((async()=>await(e.hostUpdate?.())))))),await(this._originalLifecycles.componentWillUpdate?.call(this.component))}_componentDidUpdate(){this._controllers.forEach((e=>"triggerUpdated"in e?e.triggerUpdated():m((()=>e.hostUpdated?.())))),this._originalLifecycles.componentDidUpdate?.call(this.component);const e=this._updatePromise;this._updatePromise=new l,e.resolve(!0)}async destroy(){this.ensureHasDestroy(),this.destroyed||(this.component.el.isConnected&&(this.hasDestroy=!1,this.component.el.remove(),this.hasDestroy=!0),this.destroyed=!0,this._controllers.forEach((e=>"triggerDestroy"in e?e.triggerDestroy():m((()=>e.hostDestroy?.())))),await(this._originalLifecycles.destroy?.call(this.component)))}_preserveOnDisconnectWatcher(){this.component.el.isConnected||this.component.preserveOnDisconnect||this.destroy().catch(console.error)}readonly(e){return this.getSet(e,{set:this._readonlySetter})}getSet(e,t){return this.component.manager.trackPropKey((o=>{var n;if(void 0===o)throw new Error("Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = this.manager.getSet(defaultValue,{get,set})");t.set===this._readonlySetter&&((n=this.internals).readonlyProps??(n.readonlyProps=new Set),this.internals.readonlyProps.add(o));const s=this.component,r=s[o];if(null!=r&&r!==e&&"function"==typeof t.set&&!1!==t.initialSet){const n=t.set(r,e,o);n!==r&&(s[o]=n)}this.genericGetSet(o,t)}),e)}},K="\nIf the component uses a controller that uses destroy() method, then the\ncomponent must have the following properties:\npreserveOnDisconnect and destroy\n".trim(),q=e=>(...t)=>{const o=S.internals.retrieveParentControllers(),n=new e(...t),s=n.exports;S.internals.setParentController(o.at(-1));const r=n.component.manager.internals;r.markExports(n,s),n.watchExports((e=>r.markExports(n,e))),S.internals.setAmbientChildController(n);const i=[n.component,...o].reverse();return r.trackKey(i,(e=>void 0===e?void 0:function(e,t,o,n){const s=t,r=s[o]!==e.exports,i=s[o]!==n,a=n!==e.exports;r&&!i&&a&&(s[o]=e.exports);e.watchExports((()=>{if(s[o]===e.exports)return;const t=e.component.manager;!0===t.internals.readonlyProps?.has(o)?t.bypassReadonly((()=>{s[o]=e.exports})):s[o]=e.exports}))}(n,e.host,e.key,s)),s)};var V=e=>H(void 0,e),H=q(class extends S{constructor(e,t){super(e);const o=this.exports;try{S.internals.setAmbientComponent(this.component);const e=t(this.component,this),n=this.exports!==o;if(e instanceof Promise){n||this.setProvisionalExports(e);const t=e.then((e=>{this.exports=e,super.catchUpLifecycle()})).catch((e=>{this._ready.reject(e),console.error(e)}));this.onLoad((async()=>await t))}else n&&void 0===e||(this.exports=e),queueMicrotask((()=>super.catchUpLifecycle()))}catch(e){this._ready.reject(e),console.error(e)}}catchUpLifecycle(){}}),z=e=>V(e),F=class extends D{constructor(e,t){super(e),this._loadAccessor=t,this.reactiveUtils=this.component.reactiveUtils,this._watchedProperties=new Set,this.setProvisionalExports(Q.makeGetterProxy(e,this._watchedProperties)),this._originalReactiveUtilsIntegration=this.component.manager.internals.reactiveUtilsIntegration,this.component.manager.internals.reactiveUtilsIntegration=this.hostLoad.bind(this)}async hostLoad(){this._loadingPromise??(this._loadingPromise=u(this._load.bind(this))),await this._loadingPromise}async _load(){void 0===this.component.reactiveUtils?this.reactiveUtils=await(0,s.i)():this.reactiveUtils=await this.use(this.component.reactiveUtils);const e=Q.gatherParameters(this,this._watchedProperties);this._instance=await this._createInstance(e);const t=i(this.component).filter((e=>!this._watchedProperties.has(e)));t.length>0&&await this._originalReactiveUtilsIntegration(t),Q.watchComponentUpdates(this,this._instance,this._watchedProperties),Q.watchAccessorUpdates(this,this._instance,this._watchedProperties),this.exports=this._instance}async _createInstance(e){return this._isAccessorConstructor(this._loadAccessor)?new this._loadAccessor(e):await this._loadAccessor(e)}_isAccessorConstructor(e){return"prototype"in e&&"declaredClass"in e.prototype}},Q={makeGetterProxy:(e,t)=>new Proxy({},{has:(e,t)=>"string"==typeof t||t in e,get:(e,o)=>{const n=Reflect.get(e,o);return"symbol"==typeof o||o in Promise.prototype||o in e||t.add(o),n}}),watchComponentUpdates(e,t,o){const n=function(e){const t=e,o=Object.entries(t.__accessor__?.metadata??{});return new Set(o.filter((([e,t])=>!0===t?.readOnly)).map((([e])=>e)))}(t),s=(e,o)=>t[o],r=(e,o,n)=>t[n]===e?e:(t[n]=e,t[n]),{component:i}=e;o.forEach((o=>{n.has(o)||(i[o]=i[o]||t[o]),e.internals.accessorGetter[o]=s,e.internals.accessorSetter[o]=r}))},watchAccessorUpdates(e,t,o){const{component:n}=e;n.manager.bypassGetter((()=>o.forEach((e=>{const o=n[e],s=t[e];null!=o&&s!==o&&(t[e]=o)})))),e.onLifecycle((()=>Array.from(o,(o=>e.reactiveUtils.watch((()=>t[o]),(()=>function(e,t,o){const n=t[o];e[o]=n}(n,t,o)),{initial:!0})))))},gatherParameters(e,t){const{component:o}=e;return Object.fromEntries(Array.from(t,(e=>[e,o[e]])).filter((([,e])=>void 0!==e)))}};function X({blocking:e=!1,name:t}={}){return V(((o,s)=>{if(s.onLifecycle((()=>C(o.el,(0,n.a)("./assets"),(({t9nLocale:e,t9nStrings:t,lang:n})=>{s.exports={...t,_lang:n,_t9nLocale:e};const r=t.componentLabel??t.widgetLabel;"string"==typeof r&&"label"in o&&null==o.label&&(o.label??(o.label=r))}),t))),e)return s.ready;const r=w(o.el);return{_lang:r.lang,_t9nLocale:r.t9nLocale}}))}var Y=e=>Z,Z=(...e)=>V(((t,o)=>{const n=t.arcgisPropertyChange;return o.onLoad((()=>o.onLifecycle((()=>e.map((e=>t.manager.watch(e,(()=>n.emit({name:e}))))))))),n}))}}]);